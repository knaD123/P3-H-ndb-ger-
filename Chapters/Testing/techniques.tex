\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Testing techniques} \label{sec:testingtechniques}
A lot of different techniques can be used to test software.
This section will focus on two common approaches; \textit{black-box testing} and \textit{white-box testing} \cite{SoftwareTesting}.
It will be explained what their differences are, when to use them and how they are used in this project.

When doing black-box and white-box testing it is possible to do it either statically as in \cref{defn:statictesting} or dynamically as in \cref{defn:dynamictesting}.

\begin{defn} \label{defn:statictesting}
Static Testing is testing software without running it.
\end{defn}

\begin{defn} \label{defn:dynamictesting}
Dynamic Testing is testing software by running it.
\end{defn}

\subsection{Black-box testing} \label{sec:blackboxtesting}
Black-box testing is performed without any knowledge of why the software behaves as it does \cite{SoftwareTesting}.
This means that the person (the tester) that tests the software cannot look at the code itself.
The tester is therefore only able to give input to the software and receive output based on the input.

\subsubsection{Static black-box testing}
As mentioned in \cref{sec:testingtechniques} black-box testing can be done statically.
Static black-box testing is when the tester tests the software without running the software and without access to the code.

Testing the product specification is considered as static black-box testing.
The reason for this is that the product specification is a document, see \cref{sec:Bug}, and therefore considered static.
If the project does not have a product specification there is at least one person in the project group that knows what is being build.
Then this person acts as a talking specification. \cite{SoftwareTesting}

The product specification tests are done in two steps:
\begin{itemize}
	\item High-level review.
	\item Low-level review.
\end{itemize}

A high-level review is done by examining the product specification for large fundamental problems, oversights and omissions.
This is done to better understand the 'whys' and 'hows' and thereby make it easier to examine the product specification in detail.
Consequently, this type of review of the product specification might seem more like research than actual testing.
There are several techniques that a tester can use to perform a high-level review of the product specification, e.g. pretend to be someone that is going to use the software or examine already existing solutions.
By examining already existing solutions the tester gets a better understanding of the specific type of software. \cite{SoftwareTesting}

Existing solutions were examined in this project, before the coding phase started, see \cref{chap:existing}.

When performing a low-level review of the product specification the tester would compare if the elements in the product specification each accomplishes these eight attributes: \cite{SoftwareTesting}

\begin{itemize}
	\item ''\textbf{Complete.} Is anything missing or forgotten? Is it thorough? Does it include everything necessary to make it stand alone?''
	\item ''\textbf{Accurate.} Is the proposed solution correct? Does it properly define the goal? Are there any errors?''
	\item ''\textbf{Precise, Unambiguous, and Clear.} Is the description exact and not vague? Is there a single interpretation? Is it easy to read and understand?''
	\item ''\textbf{Consistent.} Is the description of the feature written so that it doesn't conflict with itself or other items in the specification?''
	\item ''\textbf{Relevant.} Is the statement necessary to specify the feature? Is it extra information that should be left out? Is the feature traceable to an original customer need?''
	\item ''\textbf{Feasible.} Can the feature be implemented with the available personal, tools, and resources within the specified budget and schedule?''
	\item ''\textbf{Code-free.} Does the specification stick with defining the product and not the underlying software design, architecture, and code?''
	\item ''\textbf{Testable.} Can the feature be tested? Is enough information provided that a tester could create tests to verify its operation?''
\end{itemize}

It is also important when performing a low-level review of the product specification to look out for specific keywords and the context that they are used.
Some of these keywords are:

\begin{multicols}{2}
\begin{itemize}
	\item Always
	\item Certainly
	\item Sometimes
	\item Such as
	\item Cheap
	\item Skipped
	\item If\ldots Then\ldots
\end{itemize}
\end{multicols}

The tester should be looking out for words like those mentioned above since some words might signal that something is certain, or some words might be vague and others again might not be testable.
In the case where the words are too vague or not testable a re-definition is required. \cite{SoftwareTesting}

\subsubsection{Dynamic black-box testing}
It was, in \cref{sec:testingtechniques}, also mentioned that black-box tests can be done dynamically.
Dynamic black-box testing, see \cref{defn:dynamictesting} is where the tester is running the software but do not have access to the code.
Here the tester simply enters some input and receives some output based on the input entered. \cite{SoftwareTesting}

A great example of dynamic black-box testing is usability tests, see \cref{sec:usabilitytesting}.
In that section it will be further explained how the usability test were executed in this development project.

\subsection{White-box testing} \label{sec:whiteboxtesting}
White-box testing can be thought of as the opposite of black-box testing.
As mentioned in \cref{sec:blackboxtesting} the black-box testing is performed without access to the code, but when performing white-box testing the opposite is true.
It was mentioned in \cref{sec:testingtechniques} that white-box tests, just like black-box tests, can be performed statically and dynamically.

\subsubsection{Static white-box testing} \label{staticwhitebox}
Static white-box tests are performed without running the software with access to the code.
When performing static white-box tests, see \cref{defn:statictesting} the tester is reviewing the architecture and the design of the software.
The tester can also be reviewing the actual code for bugs. \cite{SoftwareTesting}

White-box testing is performed by doing reviews.
The reviews can vary from a simple meeting between a few programmers to a more detailed examination of the code and design of the software.
The reviewers should: \cite{SoftwareTesting}

\begin{itemize}
	\item Identify problems.
	\item Follow rules.
	\item Prepare.
	\item Write a report.
\end{itemize}

When trying to \textit{identify problems} with the software the reviewers should not just identity what is wrong with the code and the design of the software but also try to identify if something is missing.
While identifying problems, the reviewers should not criticize those who have created the problematic code or design but instead direct potential criticism at the code or design itself.
It is important to set some \textit{rules} for the review before the actual review.
The rules can be anything from what to review e.g. how many lines to what to comment on.
This helps the reviewers to know what their role at the review is and, therefore, makes it easier for the reviewers to \textit{prepare} for the review.
Most of the problems are actually found during the preparation phase which makes this phase extra important.
When the review is finished, the review group should make a \textit{report} of results of the review and pass it on the rest of the development team. \cite{SoftwareTesting}

Throughout this project GitHub \footnote{GitHub is a hosting platform for version control using Git} was used to perform peer reviews before merging new code into the software.
Every time someone had created new features, refactored some code, updated the layout etc., the new code had to be approved before it got merged into the project.
This was done to prevent introducing potential bugs to the project.
\subsubsection{Dynamic white-box testing}
Dynamic white-box testing is where the tester has access to the code and actually runs the software.
When performing dynamic white-box testing, see \cref{defn:dynamictesting, sec:whiteboxtesting}, the tester decides what to test and what not to test by inspecting the code.
The tester can test individual functionalities of the software or the software as a complete program. \cite{SoftwareTesting}

Testing individual functionalities, or units, are called \textit{unit testing}.
Unit testing is a great way to find and fix low-level bugs.
The reason for this is that, if a unit test fails, the bug must be in that unit.
When creating unit tests it usually a good idea to, not just create tests that shows the tested functionality works, but also test that the software fails when it should fail. \cite{SoftwareTesting}

Unit testing has been used to test the different functionalities of the software created during this project.
To test the cotnrollers, unit tests such as the one seen in \cref{lst:testadddoc}.

\lstinputlisting[firstline=64, lastline=81, language={[Sharp]{C}}, caption={A unit test for the Add Document action method}, label={lst:testadddoc}]{OBHandbooks/OBHandbooks.Tests/DocumentRepositoryTests.cs}

The unit tests follow the three A's, \textit{Arrange, Act, Assert}.
In the example above, a \texttt{Document} is being created in the arrange phase, line 67 to 73.
It is then added to the database in the act phase on line 76 to 77.
In the assert phase it is asserted that the database only contains a single \texttt{Document}, line 79 to 80.

Another example of how to perform unit tests is in the listing \cref{lst:repositorytest}.
This time it is tested if software fails when it should fail.

The test is testing if the software throws a \texttt{DbUpdateException} if a \texttt{Document} with a non-unique title is being added to the database.
A \texttt{Document} is created and added to the database in the arrange phase on line 86 to 92.
In this test the act and assert phases are combined, line 95 to 96, because it is asserted that a \texttt{DbUpdateException} is thrown if a \texttt{Document} with a non-unique title is added to the database.
\newpage

\lstinputlisting[firstline=83, lastline=97, language={[Sharp]{C}}, label={lst:repositorytest}, caption={A unit test for the DocumentRepository}]{OBHandbooks/OBHandbooks.Tests/DocumentRepositoryTests.cs}

Now it should be clear what black-box and white-box testing are and how it was used in this project.
In the next section usability testing will be explained; what it is, how it was executed and which features were tested.
\end{document}
