\section{Testing techniques} \label{sec:testingtechniques}
A lot of different techniques can be used to test software.
This section will focus on two common approaches to test software \textit{black-box testing} and \textit{white-box testing} \cite{SoftwareTesting}.
It will be explained what their differences are, when to use them and how they are used in this project.

% static and dynamic testing (side 56)
When doing black-box and white-box testing it is possible to do it statically or dynamically, see \cref{defn:statictesting,defn:dynamictesting}.
% Anja: Er det ikke lidt overkill med en cref, naar definitionerne er direkte nedenunder? :P

% Rasmus: Defininioterne burde måske nævne hvad det er de definerer? Kan ikke huske latex-koden for det
\begin{defn} \label{defn:statictesting}
Testing software without running it.
\end{defn}

\begin{defn} \label{defn:dynamictesting}
Testing software by running it.
\end{defn}

% Black-box testing (side 55)
\subsection{Black-box testing} \label{sec:blackboxtesting}
Black-box testing is performed without any knowledge of why the software behaves as it does \cite{SoftwareTesting}.
This means that the person (the tester) that tests the software cannot look at the code.
The tester is only able to give input to the software and receive output based on the input.

% Static black-box testing (side 56)
\subsubsection{Static black-box testing}
As mentioned in \cref{sec:testingtechniques} black-box testing can be done statically.
Static black-box testing is when the tester tests the software without running the software and without access to the code.

% Product specification (side 57)
Testing the product specification is considered as static black-box testing.
The reason for this is that the product specification is a document, see \cref{sec:Bug}, and therefore considered static.
If the project does not have a product specification there is at least one person in the project group that know what is being build - use this person as a talking product specification. \cite{SoftwareTesting}
% Anja: Den sidste sætning giver ikke mening for mig.

The product specification tests is done in two steps:

\begin{itemize}
	\item High-level review.
	\item Low-level review.
\end{itemize}

% Henrik: Dette afsnit skal muligvis omformuleres
A high-level review is done by examining the product specification for large fundamental problems, oversights and omissions.
This is done to better understand the 'whys' and 'hows' and thereby make it easier to examine the product specification in detail.
Consequently, this type of review of the product specification might seem more like research than actual testing.
% Teknikker til at lave high-level review (side 57-59)
There are several techniques that a tester can use to perform a high-level review of the product specification, e.g. pretend to be someone that is going to use the software or examine already existing solutions.
By examining already existing solutions the tester gets a better understanding of the specific type of software. \cite{SoftwareTesting}

Existing solutions were examined in this project, before the coding phase started.
This was explained in \cref{chap:existing}.

When performing a low-level review of the product specification the tester would compare if the elements in the product specification each accomplishes these eight attributes: \cite{SoftwareTesting}

\begin{itemize}
	\item ''\textbf{Complete.} Is anything missing or forgotten? Is it thorough? Does it include everything necessary to make it stand alone?''
	\item ''\textbf{Accurate.} Is the proposed solution correct? Does it properly define the goal? Are there any errors?''
	\item ''\textbf{Precise, Unambiguous, and Clear.} Is the description exact and not vague? Is there a single interpretation? Is it easy to read and understand?''
	\item ''\textbf{Consistent.} Is the description of the feature written so that it doesn't conflict with itself or other items in the specification?''
	\item ''\textbf{Relevant.} Is the statement necessary to specify the feature? Is it extra information that should be left out? Is the feature traceable to an original customer need?''
	\item ''\textbf{Feasible.} Can the feature be implemented with the available personal, tools, and resources within the specified budget and schedule?''
	\item ''\textbf{Code-free.} Does the specification stick with defining the product and not the underlying software design, architecture, and code?''
	\item ''\textbf{Testable.} Can the feature be tested? Is enough information provided that a tester could create tests to verify its operation?''
\end{itemize}

It is also important when performing a low-level review of the product specification to look out for specific keywords and the context that they are used.
%Anna: i stedet for also evt bruge ''likewise'' hvis du mener det passer ind?
Some of these keywords are:
\begin{multicols}{2}
\begin{itemize}
	\item Always
	\item Certainly
	\item Sometimes
	\item Such as
	\item Cheap
	\item Skipped
	\item If.. Then..
\end{itemize}
\end{multicols}

% Uddyb listen ovenover (side 61)
The tester should be looking out for words like those mentioned above since some words might signal that something is certain, or some words might be vague and others again might not be testable.
In the case where the words are too vague or not testable a re-definition is required. \cite{SoftwareTesting}

% Dynamic black-box testing (side 64)
\subsubsection{Dynamic black-box testing}
It was, in \cref{sec:testingtechniques}, also mentioned that black-box tests can be done dynamically.
Dynamic black-box testing is where the tester is running the software but do not have access to the code. % Henrik: Hvordan henviser jeg til defn dynamicly og tekst med black-box?
Here the tester simply enters some input and receives some output based on the input entered. \cite{SoftwareTesting}

% Hvordan har vi brugt det i vores projekt
A great example of dynamic black-box testing is usability tests, see \cref{sec:usabilitytesting}.
This is also something that have been done in this project.
It will be explained in greater detail how the usability test were executed in \cref{sec:usabilitytesting}.

\subsection{White-box testing} \label{sec:whiteboxtesting}
% Kort om white-box testing
White-box testing can be thought of as the opposite of black-box testing.
As mentioned in \cref{sec:blackboxtesting} the black-box testing is performed without access to the code, but when performing white-box testing the opposite is true.
It was mentioned in \cref{sec:testingtechniques} that white-box tests, just like black-box tests, can be performed statically and dynamically.

% Static white-box testing (side 92)
\subsubsection{Static white-box testing}
Static white-box tests are performed without running the software with access to the code. % Henrik: Hvordan, hvis nødvendigt, henviser jeg til baade defn og black-box?
When performing static white-box tests the tester is reviewing the architecture and the design of the software.
The tester can also be reviewing the actual code for bugs. \cite{SoftwareTesting} % Henrik: Er det nødvendigt at henvise til "bug" afsnittet her?

% Reviews (side 92-94)
White-box testing is performed by doing reviews.
The reviews can vary from a simple meeting between a few programmers to a more detailed examination of the code and design of the software.
The reviewers should: \cite{SoftwareTesting}

\begin{itemize}
	\item Identify problems.
	\item Follow rules.
	\item Prepare.
	\item Write a report.
\end{itemize}

When trying to \textit{identify problems} with the software the reviewers should not just identity what is wrong with the code and the design of the software, they should also try to identify if something is missing.
While identifying problems, the reviewers should not criticise those who have created the problematic code or design but instead direct potential criticism at the code or design itself.
It is important to set some \textit{rules} for the review before the actual review.
The rules can be anything from what to review (e.g. how many lines) to what to comment on.
This helps the reviewers to know what their role at the review is and, therefore, makes it easier for the reviewers to \textit{prepare} for the review.
Most of the problems are actually found during the preparation phase and this makes this phase extra important.
When the review is finished, the review group should make a \textit{report} of results of the review and pass it on the rest of the development team. \cite{SoftwareTesting}
% Anja: Ovenstaaende tekst er er skidegodt! Ingen kritik her

The project group has, throughout this project, used GitHub \footnote{GitHub is a hosting platform for version control using Git} to perform peer reviews before merging new code into the project. % Henrik: "into the project" skal nok omformuleres
Every time someone in the project group had created new features, refactored some code, updated the layout etc., the new code had to be approved by other members of the project group before it got merged into the project.
This was done to prevent introducing potential bugs to the project.
It also helped to keep other members of the project group up-to-date with the code.
% Anja: Jeg tænker ift. den ovenstaaende tekst, om det skal flyttes i bunden af sektionen? Her kan der staa refleksioner om, hvordan vi har brugt de der test-teknikker i løbet af projekt-perionen. Det virker bare lidt malplaceret, at vi reflekterer for test midt i al teorien, naar det ikke er blevet gjort andre stedet i white-box og black-box afsnittet.

% Dynamic white-box testing (side 105)
\subsubsection{Dynamic white-box testing}
Dynamic white-box testing is where the tester has access to the code and actually runs the software. % Henrik: Hvordan henviser jeg til defn og white-box testing?
When performing dynamic white-box testing the tester decides what to test and what not to test by inspecting the code.
The tester can test individual functionalities of the software and the software as a complete program. \cite{SoftwareTesting}

% Unit testing (side 109)
Testing individual functionalities, or units, are called \textit{unt testing}.
Unit testing is a great way to find and fix low-level bugs.
The reason for this is that, if a unit test fails, the bug must be in that unit.
When creating unit tests it usually a good idea to, not just create tests that shows the tested functionality works, but also test that the software fails when it should fail. \cite{SoftwareTesting}

Unit testing has been used to test the different functionalities of the software created during this project.
Below are a few examples of how the unit tests were created to test the different functionalities in this project:

\lstinputlisting[firstline=64, lastline=81, language={[Sharp]{C}}]{OBHandbooks/OBHandbooks.Tests/DocumentRepositoryTests.cs}

The unit tests follow the three A's, \textit{Arrange, Act, Assert}.
In the example above, a \texttt{Document} is being created in the arrange phase, line 67 to 73.
It is then added to the database in the act phase on line 76 to 77.
In the assert phase it is asserted that the database only contains a single \texttt{Document}, line 79 to 80.

Another example of how to perform unit tests.
This time it is tested if software fails when it should fail.

\lstinputlisting[firstline=83, lastline=97, language={[Sharp]{C}}]{OBHandbooks/OBHandbooks.Tests/DocumentRepositoryTests.cs}

This test is testing if the software throws a \texttt{DbUpdateException} if a \texttt{Document} with a non-unique title is being added to the database.
A \texttt{Document} is created and added to the database in the arrange phase on line 86 to 92.
In this test the act and assert phases are combined, line 95 to 96, because it is asserted that a \texttt{DbUpdateException} is thrown if a \texttt{Document} with a non-unique title is added to the database.


Now it should be clear what black-box and white-box testing are and how it was used in this project.
In the next section usability testing will be explained; what it is, how it was executed and what features were tested.
