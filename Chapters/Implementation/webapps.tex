\section{Web Applications}
The requirements in the system definition state that users should be able to work together through the system, independent of geography.
The OOAL\&D method designates that in these scenarios, the client-server model should be considered.
% RÃ¸de aalborg, side 202

The model we have decided to work with here is that of local presentation.
As the integrity of the data is incredibly important, all business logic should be centrally administrated, and that way be resillient to user error.
Choosing a local presentation model allows us to create a web application.
A web application has many advantages, including but not limited to, mature UI, easy cross platform support, and avoiding having to install anything.

A web application is any form of application where the client runs in a web browser.
This section will take a general overview of how web applications are structured, and what can be done to ensure stability.

\subsection{Frontends}
The languages of UI on the web are HTML, CSS, and Javascript.
\subsection{Hosting}
All client-server systems need a server.
While this is something that can be done on your own, it is often more hassle than it's worth, and at the same time, more expensive than simply renting server space in the cloud.

No matter how you choose to host the server, it will also need to run the server application, and often a series of other supporting applications.
The series of applications running on the server is commonly referred to as the \textit{stack}.
A common stack for the type of web app developed in this report consists of:
\begin{itemize}
\item The application itself
\item A firewall
\item A database
\item A monitoring application
\item A reverse proxy.
Formerly, the most popular choice was Apache, but this has shifted to Nginx.
\item SSH, or similar remote access utility
\end{itemize}
Additionally, if we end up implementing this requirement, we may or may not need to setup mail software to send notification emails to users.
\subsection{NixOps}
NixOps is a non-standard way to deploy servers, but it is in large growth.
Based on the declarative Nix programming language, NixOps allows one to define a server network declaratively, a approach far more powerful than classical imperative CM systems.
Having the entire server stack being easily reproducible makes reproducing bugs, and general development far easier, than if the environment on production and testing were vastly different.
The nix code for the server used is quite short, so it's placed in appendix XX.

\subsection{Monitoring}
"A commitment to monitoring is the distinguishing characteristic of a professional system administrator." - Unix and Linux system administration handbook
% This chapter is mostly based on this book.
A damn goood book btw, can recommend

Monitoring is the practice of gathering metrics, events, and trends from the application, in order to get an understanding of how the application is performing.
In server applications, this is crucial, as it allows system administrators to notice and prevent the problem before the screaming starts.
Most monitoring solutions allow for overviews of how the system is currently performing, but also sending of notifications under certain circumstances, for example if a server is running out of storage, or it is often under stress, or crashes occur.

To integrate our application with monitoring, it needs to somehow expose metrics.
One of the standard ways to do it is hosting a text document at /metrics, consisting of key-value stores in the form "metric: value".
A metrics system will then poll the endpoint at a set interval, and use the fetched values to provide statistics about the monitored system.

For this project, it was decided that Prometheus/Grafana would be used, as that was what the project group had experience with.
