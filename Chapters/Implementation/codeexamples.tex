\section{Code examples}\label{sec:codeexamples}
In this section examples of the code will be presented.
As written in \cref{sec:systemdesign} the system is based on the ASP.NET Core MVC architecture including EF Core.
How the system utilizes the MVC architecture and the EF Core framework will be shown in the following code examples.

First, the MVC implementation is explored with the \texttt{Document} class.
How the \texttt{Document} object behaves in the system will be explored through the model, view, and controller components.
Furthermore it will be shown how the document data will be created, and then stored in the database with the repository pattern and EF Core.

\subsection{Model}

In the model component the \texttt{Document} object is defined.
It is primarily the document object that will be highlighted in the code examples.
How the document object is presented is shown in the code listing below:
\\
\begin{lstlisting}[caption={Document Model: Document object}, label={lst:doc}]
[Key]
public int ID { get; set; } //for the database

public virtual Chapter Chapter { get; set; } //first part of document ID

public int ChapterNumber
{
	get
	{
		return Chapter != null ? Chapter.Number : -1;
	}
}

[Range(1, Int32.MaxValue)]
[Display(Name = "Section")]
public int SectionNumber { get; set; } //second part of Document ID

[Required]
public string Title { get; set; }

public virtual ICollection<Version> Versions { get; set; } //List of all past versions of the document (the "archive")
public virtual IEnumerable<DocumentDepartment> DocumentDepartments { get; set; }

public bool Archived { get; set; }

public Document()
{
	Archived = false;
}
\end{lstlisting}

The document object includes an ID, chapter, section number, versions, and whether or not it has been archived as seen in the code listing above, \cref{lst:doc}.
The \texttt{Key} attribute on line 1 specifies that the \texttt{int ID} is a primary key that the database can use to identify the specific document.
Likewise, the \texttt{Range} attribute specifies that the section number is restricted to a range from 1 to the max value of a 32 bit integer.
And the \texttt{Display} attribute on line 15 specifies that the section number should be displayed with the name \textit{section}.
This \texttt{Display} attribute is used to modify the text when the model displayed in a view.

In the code listing below, \cref{lst:addversion}, it is shown the logic of how a new version of a document is added to a document after it has been approved.
\\

\begin{lstlisting}[caption={Document Model: AddVersion}, label={lst:addversion}]
public void AddVersion(Version version)
{
	version.ValidFromDate = DateTime.Now;
	version.Approved = true;
	Versions.Add(version);
	int nVersions = Versions.Count;
	var oldVersion = Versions.ElementAtOrDefault(nVersions - 1);

	if (nVersions >= 2 && oldVersion != null)
	{
		oldVersion.ValidUntilDate = DateTime.Now;
	}
	foreach (DocumentDepartment dd in DocumentDepartments)
	{
		dd.Department.Notify("The document " + Title + " has been updated", "http://localhost:5000/document/" + Chapter.Number.ToString() + "." + SectionNumber.ToString());
	}
}
\end{lstlisting}

When a new version of a document is added the version's \texttt{ValidFromDate} is set to the current date and the \texttt{Approved} bool is set to \texttt{true} as seen on line 3 and 4.
On line 5 the new version is added to the list of versions.
The selection control structure from line 9 - 12 ensures that the previous version's ValidUntilDate is set to the current date.
When a new version has been added all of the affected departments in the system will get notified as seen in the iteration control structure from line 13 - 16.

\subsection{Controller}

In \cref{lst:doccontroller,lst:doccontrolleradd} it is shown how a \texttt{HttpGet} and \texttt{HttpPost} methods are implemented in the controller component.
Firstly, it is shown how the document object is arranged so that it can be passed to the view through the \texttt{HttpGet} method.
\\

\begin{lstlisting}[caption={Document Controller: Index}, label={lst:doccontroller}]
[HttpGet("")]
[HttpGet("document/")]
public async Task<IActionResult> Index()
{
	var user = await this._userManager.GetUserAsync(HttpContext.User);
	var documentIndex = new ViewModels.DocumentIndex();
	foreach (var ud in user.UserDepartments)
	{
		foreach (var dd in ud.Department.DocumentDepartments)
		{
			if (!dd.Document.Archived) documentIndex.AssignedDocuments.Add(dd.Document);
		}
	}
	List<Document> documentList = await this._documentRepository.ListNonArchivedAsync();
	foreach (var d in documentIndex.AssignedDocuments)
	{
		documentList.Remove(d);
	}

	foreach (var d in documentList)
	{
		if (!documentIndex.UnassignedDocuments.ContainsKey(d.Chapter))
		documentIndex.UnassignedDocuments[d.Chapter] = new List<Document>();
		documentIndex.UnassignedDocuments[d.Chapter].Add(d);
	}

	@ViewData["Title"] = "Table of Contents";

	return View(documentIndex);
}
\end{lstlisting}

The \texttt{HttpGet} method means that the method only can be accessed by a \texttt{GET} requests.
Something to take note of in \cref{lst:doccontroller} is the \texttt{async Task<IActionResult>} on line 3.
The \texttt{Task} class represents a single operation \cite{microsoft} performed asynchronously.
The \texttt{IActionResult} type parameter means that upon completion, it returns an \texttt{IActionResult} object.

From line 5-13 it is determined which documents that the current user is assigned to.
This is done by retreiving the current user from the \texttt{_userManager}, by finding a user in the list that matches the one found in the \texttt{HttpContext}.
Afterwards, the program iterates through the departments which the user is a part of to find which documents they are assigned to.
This is done through the iterative control structure on line 9 - 12.

After the list of documents the user has not been assigned to have been organized into chapters, it will be added to the viewmodel.
This is done through the two foreach loops from line 14 - 25.
All of the non-archived documents are returned to the view through \texttt{var documentIndex} on line 29.

In \cref{lst:doccontrolleradd} it is shown what happens when the user adds a new document or version to the system through the \texttt{Add} method.
\\
\lstinputlisting[caption={Document Controller: Add}, label={lst:doccontrolleradd}, firstline=152, lastline=233, autogobble=true, tabsize=2]{OBHandbooks/OBHandbooks/Controllers/DocumentController.cs}

%Anna: Evt sætte denne specifikke listing i appendiks? (er emget lang for meget lidt der fås ud af den)

The \texttt{HttpPost} method ensures that it can only be accessed by a \texttt{POST} requests.

%Taniya: måske forklar hvaf IFormfile er for noget?
The information from the view is transfered into the controller method through the parameters shown from line 2-7.
When the document is posted to the controller the \texttt{Add} method ensures that the new document version needs to be approved, see line 9.
% Henrik: Paa linje 9 bliver der bare lavet en variable - true hvis strengen er "on", ellers false
Afterwards the actual document receives its chapter number on line 16 and is saved into the document repository on line 29 through the \texttt{AddAsync} method.
% Henrik: Den faar faktisk sit chapter number paa linje 25 - linje 9 henter bare et chapter fra databasen
A more detailed explanation of the \texttt{AddAsync} method can be seen in \cref{lst:docrepadd}.

The new version of the document is stored into the repository on line 36-62.
Here the new version is saved into the version repository on line 40 with the \texttt{AddAsync} method.
Notice that the \texttt{_documentRepository.AddAsync} and \texttt{_versionRepository.AddAsync} are similarly named, but respectively saves a document and a version.

The new document version is not yet valid to the readers as it needs to be approved.
From line 45-55 the program creates an approval object or objects where it is determined which users need to approve the new version.
If the new version does not need an approval, it is simply saved into the repositories on line 60-61.

\subsection{View}

In \cref{lst:docview} it is shown how the \texttt{view} component utilizes data given from the \texttt{controller} component.

\begin{lstlisting}[caption={Document View: Index}, label={lst:docview}]
@foreach (KeyValuePair<Models.Chapter, List<Models.Document>> kvp in Model.UnassignedDocuments) {
<button class="btn btn-outline-dark text-left pl-4 mt-1" onclick="listExpand()" style="width: 100%; margin-top: 10px;" type="button" data-toggle="collapse" data-target="#collapseChapter-@kvp.Key.Number" aria-expanded="false" aria-controls="collapseExample">
<div class="row">
	@kvp.Key.Number | @kvp.Key.Name
	<i class="fas fa-chevron-down ml-auto mr-4 arrow-toggle"></i>
</div>
</button>
<div class="collapse card" id="collapseChapter-@kvp.Key.Number">
	<div class="card-body" style="padding: 0.1rem">
		<table class="table table-striped table-sm">
			<thead class="border font-weight-bold">
				<tr>
					<td>ID</td>
					<td>Title</td>
					<td>Version</td>
					<td>Date</td>
					<td>Read status</td>
					@if (User.IsInRole("Administrator"))
					{
						<td></td>
					}
				</tr>
			</thead>
		<tbody>
			@await Html.PartialAsync("_DocumentListBody", @kvp.Value)
		</tbody>
		</table>
	</div>
</div>
}

\end{lstlisting}

\cref{lst:docview} is the view that represents a list of assigned documents.
This will render to a button, which when clicked expands a list of documents in a given chapter.
It is written in the razor templating language, which is HTML with the added feature of allowing the documents to be dynamic when prefacing a statement with the \texttt{@} character.
% Henrik: @ betyder faktisk "her starter noget C# kode", saa tænker at maaske flet ind at razor gør det muligt at skrive C# kode inde i ens HTML?
%Anna: vi skal i hvert fald være præcise så kunne være en ide
An interesting thing to note is line 25, where the statement \texttt{@await Html.PartialAsync("_DocumentListBody", @kvp.Value)} is executed.
This statement asks the razor templating engine to render the body of a list of documents, with the argument that is the list of documents in the current chapter.
% Henrik: Første argument er navnet paa det view den skal render (filnavn)
%Anna: kan godt være det bare er mig, men synes den sidste sætning er kringlet og er ikke iskker på jeg forstå den ordentligt

\subsection{Repositories}

In the \texttt{repositories} component the data is processed.
In \cref{lst:docrepadd} it is shown how a document is added to the database.

\begin{lstlisting}[caption={Document repository: AddAsync}, label={lst:docrepadd}]
public async Task<Document> AddAsync(Document document)
{
	if (this._dbContext.documents.Where(
			d => d.Chapter == document.Chapter && d.SectionNumber == document.SectionNumber
			).SingleOrDefault() != null)
	{
		throw new DocumentAddException("Chapter/section number is not unique");
	}

	if (this._dbContext.documents.Where(d => d.Title == document.Title).FirstOrDefault() != null)
	{
		throw new DocumentAddException("Title is not unique");
	}
	var ret = this._dbContext.documents.Add(document); //documents er en attribute af typen DbSet
	await this._dbContext.SaveChangesAsync();
	return ret.Entity;
}
\end{lstlisting}


This is a method in the \texttt{DocumentRepository}, which allows for adding documents to the database.
%Anna: what is mentioned. man kan ikke starte en sætning med This uden at det vser tilabge til noget, så hvad er det der menes?
It first performs two checks, to see if the database already contains a document.
If that is the case, it throws the custom \texttt{DocumentAddException}.
Otherwise, it adds the document to the database, and returns the tracked database entry.
The reason why this is important, and that one cannot just use the \texttt{Document} object supplied as an argument, is due to the use of lazy-loading proxies in the application.
Lazy-loading proxies funcions in such a way that when objects have relationships with other objects, these are implemented as virtual properties.
% Taniya: menes der function (funcion)?  Og hvilke linje er det vi taler om ?
% Henrik: Taniya, igen - bare fix stavefejl :-P

\todo[inline]{Skal vi forklare hvad lazy loading betyder, eller er det basic nok til vi kan slippe?}
%Anna: tænker i hvert fald det er fint at have lidt om det
% Taniya: må gerne forklar det kort, hvis muligt
\todo[inline]{Tanke: Har vi noget om hvad async er for noget, og er det noget vi eventuelt skal have med? Eller gider vi lave ny tekst saa tæt paa aflevering?}

In the case of the \texttt{AddAsync} method, this means that you can construct a raw \texttt{Document} object, pass it to the method, and then get a proxy object in return.
This allows for assigning to the virtual members, which is a functionality that is heavily used in the controllers.
%Anna: vil mene afsnittet ovenfor hører sammen med den ovenover.
\input{Chapters/Implementation/efcore}
