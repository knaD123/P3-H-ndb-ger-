\section{Code examples}
In this section examples of the code will be presented.
As written in \cref{sec:systemdesign} the system is based on the ASP.NET Core MVC architecture including EF Core.
How the system utilizes the MVC architecture and the EF Core framework will be shown in the following code examples.

Firstly the MVC implementation is explored with the Document class.
How the Document object is being treated throughout the system will be presented throught the model, view, and controller components.
Furthermore it will be shown how the document data will be stored in the database with the repository pattern and EF Core.

\subsection{Model}

\begin{lstlisting}
[Key]
public int ID { get; set; } //for the database

public virtual Chapter Chapter { get; set; } //first part of doocument ID

public int ChapterNumber
{
	get
	{
		return Chapter != null ? Chapter.Number : -1;
	}
}

[Range(1, Int32.MaxValue)]
[Display(Name = "Section")]
public int SectionNumber { get; set; } //second part of Document ID

[Required]
public string Title { get; set; } // TODO: Unique title of document

public virtual ICollection<Version> Versions { get; set; } //List of all past versions of the document (the "archive")
public virtual IEnumerable<DocumentDepartment> DocumentDepartments { get; set; }

public bool Archived { get; set; }

public Document()
{
	Archived = false;
}

\end{lstlisting}

\begin{lstlisting}
public void AddVersion(Version version)
{
	version.ValidFromDate = DateTime.Now;
	version.Approved = true;
	Versions.Add(version);
	int nVersions = Versions.Count;
	var oldVersion = Versions.ElementAtOrDefault(nVersions - 1);

	if (nVersions >= 2 && oldVersion != null)
	{
		oldVersion.ValidUntilDate = DateTime.Now;
	}
	foreach (DocumentDepartment dd in DocumentDepartments)
	{
		dd.Department.Notify("The document " + Title + " has been updated", "http://localhost:5000/document/" + Chapter.Number.ToString() + "." + SectionNumber.ToString());
	}
}
\end{lstlisting}

\subsection{Controller}

\begin{lstlisting}
[HttpGet("")]
[HttpGet("document/")]
public async Task<IActionResult> Index()
{
	var user = await this._userManager.GetUserAsync(HttpContext.User);
	var documentIndex = new ViewModels.DocumentIndex();
	foreach (var ud in user.UserDepartments)
	{
		foreach (var dd in ud.Department.DocumentDepartments)
		{
			if (!dd.Document.Archived) documentIndex.AssignedDocuments.Add(dd.Document);
		}
	}
	List<Document> documentList = await this._documentRepository.ListNonArchivedAsync();
	foreach (var d in documentIndex.AssignedDocuments)
	{
		documentList.Remove(d);
	}

	foreach (var d in documentList)
	{
		if (!documentIndex.UnassignedDocuments.ContainsKey(d.Chapter))
		documentIndex.UnassignedDocuments[d.Chapter] = new List<Document>();
		documentIndex.UnassignedDocuments[d.Chapter].Add(d);
	}

	@ViewData["Title"] = "Table of Contents";

	return View(documentIndex);
}
\end{lstlisting}

\begin{lstlisting}
[HttpPost("document/add/")]
public async Task<IActionResult> Add(Document document,
	int chapterNumber,
	IFormFile versionFile,
	IFormFile workingFile,
	string requireApprovalCheck,
	string approvers)
{
	bool requireApproval = (requireApprovalCheck == "on");
	@ViewData["Title"] = "New document";
	@ViewBag.Chapters = await _chapterRepository.GetChapters();

	if (ModelState.IsValid)
	{
		document = this._documentRepository.ToProxy(document);
		var chapter = await this._chapterRepository.GetChapter(chapterNumber);

		if (chapter == null)
		{
			ModelState.AddModelError(string.Empty, "Problem happend getting the chapter.");

			return View(document);
		}

		document.Chapter = chapter;

		try
		{
			document = await this._documentRepository.AddAsync(document);
		}
		catch (DocumentAddException e)
		{
			ModelState.AddModelError(string.Empty, e.ModelError);
			return View(document);
		}
		if (versionFile != null)
		{
			OBHandbooks.Models.Version version = new OBHandbooks.Models.Version();
			version.SetDocument(document);
			version = await this._versionRepository.AddAsync(version);

			version.VersionFile = new HandbookFile(versionFile);
			if (workingFile != null) version.WorkingFile = new HandbookFile(workingFile);

			if (requireApproval)
			{
				HandbookApproval approval = await CreateApproval(
				approvers,
				await this._userManager.GetUserAsync(HttpContext.User));
				approval.DocumentVersion = version;
				version.DateSubmittedToApproval = DateTime.Now;
				document.Versions.Add(version);
				approval.CheckForApproval();
				await this._approvalRepository.UpdateAsync(approval);
			}
			else
			{
				document.AddVersion(version);
			}
			await this._documentRepository.UpdateAsync(document);
			await this._versionRepository.UpdateAsync(version);
		}
		return RedirectToAction(nameof(Index));

	}

	return View(document);
}

\end{lstlisting}

\subsection{View}

\begin{lstlisting}
@foreach (KeyValuePair<Models.Chapter, List<Models.Document>> kvp in Model.UnassignedDocuments) {
<button class="btn btn-outline-dark text-left pl-4 mt-1" onclick="listExpand()" style="width: 100%; margin-top: 10px;" type="button" data-toggle="collapse" data-target="#collapseChapter-@kvp.Key.Number" aria-expanded="false" aria-controls="collapseExample">
<div class="row">
	@kvp.Key.Number | @kvp.Key.Name
	<i class="fas fa-chevron-down ml-auto mr-4 arrow-toggle"></i>
</div>
</button>
<div class="collapse card" id="collapseChapter-@kvp.Key.Number">
	<div class="card-body" style="padding: 0.1rem">
		<table class="table table-striped table-sm">
			<thead class="border font-weight-bold">
				<tr>
					<td>ID</td>
					<td>Title</td>
					<td>Version</td>
					<td>Date</td>
					<td>Read status</td>
					@if (User.IsInRole("Administrator"))
					{
						<td></td>
					}
				</tr>
			</thead>
		<tbody>
			@await Html.PartialAsync("_DocumentListBody", @kvp.Value)
		</tbody>
		</table>
	</div>
</div>
}

\end{lstlisting}
This is the view that represents a list of assigned documents. This will render to a button, which when clicked expands a list of documetns in the chapter the button represents.
It's written in the razor templating langugae, which is HTML, but with the added feature of allowing the documents to be dynamic when prefacing a statement with the \texttt{@} character.
An interesting thing to note is on line 25, where the statement \texttt{@await Html.PartialAsync("_DocumentListBody", @kvp.Value)} is executed.
This statement asks the razor templating engine to render the body of a list of documetns, with the argument that is the list of documents in the current chapter.

\subsection{Repositories}

\begin{lstlisting}
public async Task<Document> AddAsync(Document document)
{
	if (this._dbContext.documents.Where(
			d => d.Chapter == document.Chapter && d.SectionNumber == document.SectionNumber
			).SingleOrDefault() != null)
	{
		throw new DocumentAddException("Chapter/section number is not unique");
	}

	if (this._dbContext.documents.Where(d => d.Title == document.Title).FirstOrDefault() != null)
	{
		throw new DocumentAddException("Title is not unique");
	}
	var ret = this._dbContext.documents.Add(document); //documents er en attribute af typen DbSet
	await this._dbContext.SaveChangesAsync();
	return ret.Entity;
}
\end{lstlisting}
This is a method in the \texttt{DocumentRepository}, which allows for adding documents to the database.
It first performs to checks, to see if the database already contains a document.
If that is the case, it throws the custom \texttt{DocumentAddException}.
Otherwise, it adds the document to the database, and returns the tracked database entry.
The reason that this is important, and that one can't just use the \texttt{Document} object supplied as an argument, is due to the use of lazy-loading proxies in the application.
Lazy-loading proxies funcion so that when objects have relationships with other object, these are implemented as virtual properties.

\todo[inline]{Skal vi forklare hvad lazy loading betyder, eller er det basic nok til vi kan slippe?}

In the case of the \texttt{AddAsync} method, this means that you can construct a raw \texttt{Document} object, pass it to the method, and then get a proxy object in return.
This allows for assigning to the virtual members, which is a functionality that is heavily used in the controllers.
\input{Chapters/Implementation/efcore}
